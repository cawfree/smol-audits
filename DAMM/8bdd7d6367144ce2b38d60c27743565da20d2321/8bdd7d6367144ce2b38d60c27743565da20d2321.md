# DAMM Capital v4 Security Assessment

| Key             | Value                                       |
|-----------------|---------------------------------------------|
| **Client**      | [__DAMM Capital__](https://dammcap.finance) |
| **Codebase**    | https://github.com/bauti-defi/Contracts-V4  |
| **Commit Hash** | `8bdd7d6367144ce2b38d60c27743565da20d2321`  |
| **Chain(s)**    | Arbitrum                                    |
| **Scheme**      | Pay Per Vulnerability                       |
| **Date**        | 14th August 2024                            |

| **Methodology**  |   |
|------------------|---|
| Manual Review    | ✅ |
| Static Analyzers | ✅ |
| Test Suite       | ✅ |
| Fuzzing          | ✅ |

# About DAMM

[__DAMM Capital__](https://dammcap.finance) executes strategies rooted in data-driven analytics to unlock capital growth through the deployment of decentralized mutuals funds on the Ethereum ecosystem. Each fund is unique, executing according to a customizable risk profile.

This audit focuses on the `v4` transaction module contracts.

# Scope

```
src/
└── modules/
    └── transact/
        ├── HookRegistry.sol
        ├── Hooks.sol
        ├── Structs.sol
        └── TransactionModule.sol
└── hooks/
    ├── aaveV3
    │   └── AaveV3Hooks.sol
    └── uniswapV3
        └── UniswapV3Hooks.sol
```

# Findings

> ## M-01 | Maximum Priority Gas Limitations Are Ineffective
> 
> ### Description
> 
> To protect against abuse of the [`TransactionModule`](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/modules/transact/TransactionModule.sol)'s gas refund mechanism for transaction keepers, the [`refundGasToCaller`](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/modules/transact/TransactionModule.sol#L30C14-L30C31) modifier imposes the following safeguard against excessively high call gas:
> 
> ```solidity
> /// failsafe for caller not to be able to set a gas price that is too high
> /// the fund can update this limit in moments of emergency (e.g. high gas prices, network congestion, etc.)
> /// gasPriority = tx.gasprice - block.basefee
> /// @dev the chain must be EIP1559 complient to support `basefee`
> if (
>     maxGasPriorityInBasisPoints > 0 && tx.gasprice > block.basefee
>         && ((tx.gasprice - block.basefee) * BP_DIVISOR) / tx.gasprice
>             >= maxGasPriorityInBasisPoints
> ) {
>     revert Errors.Transaction_GasLimitExceeded();
> }
> ```
> **However, these protections are ineffective**. Let's consider the following scenario:
> 
> | **Key**                       | **Value**     |
> |-------------------------------|---------------|
> | `tx.gasprice`                 | `1.11 gwei`   |
> | `block.basefee`               | `1 gwei`      |
> | `maxGasPriorityInBasisPoints` | `1_000` (10%) |
> 
> In this configuration, we would expect the maximum `tx.gasprice` supported by the module to be 10% over the `block.basefee` (`1.1 gwei`), however:
> 
> ```
>   ((tx.gasprice - block.basefee) * BP_DIVISOR) / tx.gasprice
> = ((1110000000 - 1000000000) * 10_000) / 1110000000
> = 990
> ```
> 
> Due to an oversight in the basis point calculation, it is possible for the caller to transact at a higher priority gas than intended, since instead of computing the ratio relative to the `block.basefee`, we compute with respect to the `tx.gasprice`, which exhibits a nonlinear relationship.
> 
> Furthermore, the comparison itself is susceptible to an off-by-one error, since if the transaction were priced at exactly the `maxGasPriorityInBasisPoints`, the call would `revert` due to the use of the `>=` operator instead of `>`, even though the transaction was correctly priced. This can unfairly DoS keepers.
>
> Additionally, we advise that the `fund` is offered no mechanisms to enforce the upper bound on the number of gas units that can be consumed by the keeper, which also has the potential to be excessive.
> 
> Finally, although the provided implementation provides assurances against keepers transacting at too great a priority fee over the `block.basefee`, it offers no protections against the keeper attempting to procure refunds during periods of high network congestion, **when the** `block.basefee` **itself might be excessive**.
> 
> ### Impact
> 
> Keepers may be refunded for transactions made at significantly higher gas than intended.
> 
> ### Recommendation
> 
> The updated safeguard is listed  below:
> 
>```diff
>+ @notice Prevent keepers from executing during
>+ @notice periods of high network congestion.
>+ if (block.basefee > maximumBaseFee)
>+   revert Errors.Transaction_BaseFeeExceeded();
>+
>  if (
>     maxGasPriorityInBasisPoints > 0 && tx.gasprice > block.basefee
>-        && ((tx.gasprice - block.basefee) * BP_DIVISOR) / tx.gasprice
>-            >= maxGasPriorityInBasisPoints
>+        && ((tx.gasprice - block.basefee) * BP_DIVISOR) / block.basefee
>+            > maxGasPriorityInBasisPoints
> ) {
>     revert Errors.Transaction_GasLimitExceeded();
> }
> ```
>
> It should be emphasized that the recommendation to `revert` if the `block.basefee` is hypothetical and may impact upon transaction liveness.
