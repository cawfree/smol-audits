# DAMM Capital v4 Security Assessment

| Key             | Value                                       |
|-----------------|---------------------------------------------|
| **Client**      | [__DAMM Capital__](https://dammcap.finance) |
| **Codebase**    | https://github.com/bauti-defi/Contracts-V4  |
| **Commit Hash** | `8bdd7d6367144ce2b38d60c27743565da20d2321`  |
| **Chain(s)**    | Arbitrum                                    |
| **Scheme**      | Pay Per Vulnerability (H + M)               |
| **Date**        | 14th August 2024                            |

| **Methodology**  |  |
|------------------|--|
| Manual Review    | ✅ |
| Static Analyzers | ✅ |
| Test Suite       | ✅ |
| Fuzzing          | ✅ |

# About DAMM Capital

[__DAMM Capital__](https://dammcap.finance) executes strategies rooted in data-driven analytics to unlock capital growth through the deployment of decentralized mutuals funds on the Ethereum ecosystem. Each fund is unique, executing according to a customizable risk profile.

This audit focuses on the `v4` transaction module contracts.

# Scope

```
src/
└── modules/
    └── transact/
        ├── HookRegistry.sol
        ├── Hooks.sol
        ├── Structs.sol
        └── TransactionModule.sol
└── hooks/
    ├── aaveV3
    │   └── AaveV3Hooks.sol
    └── uniswapV3
        └── UniswapV3Hooks.sol
```

# Actors

| **Role**      | **Relationship** |
|---------------|------------------|
| Fund          | **Trusted**      |
| Fund Operator | **Trusted**      |

We operate under the assumption that all **Trusted** actors act exclusively in the best interests of the protocol.

# Findings

> ## M-01 | Maximum Priority Gas Limitations Are Ineffective
> 
> ### Description
> 
> To protect against abuse of the [`TransactionModule`](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/modules/transact/TransactionModule.sol)'s gas refund mechanism for transaction keepers, the [`refundGasToCaller`](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/modules/transact/TransactionModule.sol#L30C14-L30C31) modifier imposes the following safeguard against excessively high call gas:
> 
> ```solidity
> /// failsafe for caller not to be able to set a gas price that is too high
> /// the fund can update this limit in moments of emergency (e.g. high gas prices, network congestion, etc.)
> /// gasPriority = tx.gasprice - block.basefee
> /// @dev the chain must be EIP1559 complient to support `basefee`
> if (
>     maxGasPriorityInBasisPoints > 0 && tx.gasprice > block.basefee
>         && ((tx.gasprice - block.basefee) * BP_DIVISOR) / tx.gasprice
>             >= maxGasPriorityInBasisPoints
> ) {
>     revert Errors.Transaction_GasLimitExceeded();
> }
> ```
> **However, these protections are ineffective**. Let's consider the following scenario:
> 
> | **Key**                       | **Value**     |
> |-------------------------------|---------------|
> | `tx.gasprice`                 | `1.11 gwei`   |
> | `block.basefee`               | `1 gwei`      |
> | `maxGasPriorityInBasisPoints` | `1_000` (10%) |
> 
> In this configuration, we would expect the maximum `tx.gasprice` supported by the module to be 10% over the `block.basefee` (`1.1 gwei`), however:
> 
> ```
>   ((tx.gasprice - block.basefee) * BP_DIVISOR) / tx.gasprice
> = ((1110000000 - 1000000000) * 10_000) / 1110000000
> = 990
> ```
> 
> Due to an oversight in the basis point calculation, it is possible for the caller to transact at a higher priority gas than intended, since instead of computing the ratio relative to the `block.basefee` we compute with respect to the `tx.gasprice`, which exhibits a nonlinear relationship.
> 
> Furthermore, the comparison itself is susceptible to an off-by-one error, since if the transaction were priced at exactly the `maxGasPriorityInBasisPoints`, the call would `revert` due to the use of the `>=` operator instead of `>`, even though the transaction was correctly priced. This can unfairly DoS keepers.
>
> Additionally, we advise that the `fund` is offered no mechanisms to enforce the upper bound on the number of gas units that can be consumed by the keeper, which also has the potential to be excessive.
> 
> Finally, although the provided implementation provides assurances against keepers transacting at too great a priority fee over the `block.basefee`, it offers no protections against the keeper attempting to procure refunds during periods of high network congestion, **when the** `block.basefee` **itself might be excessive**.
> 
> ### Impact
> 
> Keepers may be refunded for transactions made at significantly higher gas than desired.
> 
> ### Recommendation
> 
> The updated safeguard is listed  below:
> 
>```diff
>+ @notice Prevent keepers from executing during
>+ @notice periods of high network congestion.
>+ if (block.basefee > maximumBaseFee)
>+   revert Errors.Transaction_BaseFeeExceeded();
>+
>  if (
>     maxGasPriorityInBasisPoints > 0 && tx.gasprice > block.basefee
>-        && ((tx.gasprice - block.basefee) * BP_DIVISOR) / tx.gasprice
>-            >= maxGasPriorityInBasisPoints
>+        && ((tx.gasprice - block.basefee) * BP_DIVISOR) / block.basefee
>+            > maxGasPriorityInBasisPoints
> ) {
>     revert Errors.Transaction_GasLimitExceeded();
> }
> ```
>
> It should be emphasized that the recommendation to `revert` if the `block.basefee` is hypothetical and may impact upon transaction liveness.
> 
> ### Remediation
> 
> Unresolved

> ## M-02 | Donations To Aave `IPool` Prevent Positions From Being Closed
> 
> Negligible donations to an Aave [`IPool`](https://github.com/aave/aave-v3-core/blob/master/contracts/interfaces/IPool.sol) `onBehalfOf` an [`IFund`](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/interfaces/IFund.sol) can be used to prevent positions from being closed normally.
>
> ### Description
> 
> When executing withdrawal from an [`IPool`](https://github.com/aave/aave-v3-core/blob/master/contracts/interfaces/IPool.sol) via [`AaveV3Hooks`](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/hooks/aaveV3/AaveV3Hooks.sol), an opened position may be only fully closed out [once the `collateralDeposited` returns zero](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/hooks/aaveV3/AaveV3Hooks.sol#L90C9-L97C10):
> 
> ```solidity
> } else if (selector == L1_WITHDRAW_SELECTOR) {
>     (uint256 collateralDeposited,,,,,) = aaveV3Pool.getUserAccountData(address(fund));
> @>  if (collateralDeposited == 0) { /// @audit collateralDeposited_must_be_zero
>         if (!fund.onPositionClosed(POSITION_POINTER)) {
>             revert AaveV3Hooks_PositionClosureFailed();
>         }
>     }
> }
> ```
> 
> However, [`AaveV3Hooks`](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/hooks/aaveV3/AaveV3Hooks.sol) **is limited to only transacting using explicitly whitelisted tokens**:
> 
> ```solidity
> if (!assetWhitelist[asset]) {
>     revert AaveV3Hooks_OnlyWhitelistedTokens();
> }
> ```
> 
> Therefore, if an attacker makes a malicious donation to the [`IPool`](https://github.com/aave/aave-v3-core/blob/master/contracts/interfaces/IPool.sol) `onBehalfOf` the [`IFund`](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/interfaces/IFund.sol) using a blacklisted token, it will not be possible for the module to ever close out the position, since `collateralDeposited` will return non-zero based upon the possession of an asset the vault is not configured to transact using.
>
> ### Impact
>
> Inability to close open positions, which may degrade the effectiveness of keepers. Resolution of this issue would require the fund to manually (and exhaustively) whitelist **explicitly blacklisted tokens**.
>
> ### Recommendation
> 
> Using a common [`POSITION_POINTER`](https://github.com/bauti-defi/Contracts-V4/blob/8bdd7d6367144ce2b38d60c27743565da20d2321/src/hooks/aaveV3/AaveV3Hooks.sol#L21C22-L21C38) between all assets implicitly prevents the protocol from being able to distinguish the isolated contribution of individual assets to the portfolio, including malicious donations.
> 
> Instead, we recommend tracking multiple positions per-asset:
> 
> ```diff
> + /// @notice Computes the position pointer for a specific underlying asset.
> + /// @param underlying The underlying asset deposited into the `IPool`.
> + /// @return pointer The unique pointer for the deposited asset.
> + function getAavePositionPointer(address underlying) returns (bytes32 pointer) {
> +     pointer = keccak256(abi.encode("aave.v3.hooks", underlying));
> + }
> ```
> 
> ```diff
> } else if (selector == L1_WITHDRAW_SELECTOR) {
> + address asset;
> + assembly {
> +     asset := calldataload(data.offset)
> + }
> + /// @notice If the `aTokenBalance` is empty, attempt to close out the position:
> + uint256 aTokenBalance = IERC20(aaveV3Pool.getReserveData(asset).aTokenAddress)
> +     .balanceOf(address(fund));
> + if (aTokenBalance == 0) {
> -    (uint256 collateralDeposited,,,,,) = aaveV3Pool.getUserAccountData(address(fund));
> -    if (collateralDeposited == 0) {
>         if (!fund.onPositionClosed(getAavePositionPointer(asset))) {
>             revert AaveV3Hooks_PositionClosureFailed();
>         }
>     }
> }
> ```
> 
> In this approach, we respect the existing lifecycle of depositing and withdrawing underlying assets one-at-a-time.
>
> ### Remediation
>
> Unresolved
